require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")

# react-native-permissions
require File.join(File.dirname(`node --print "require.resolve('react-native-permissions/package.json')"`), "scripts/setup")


require 'json'
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}

ENV['RCT_NEW_ARCH_ENABLED'] = '1'
ENV['EX_DEV_CLIENT_NETWORK_INSPECTOR'] = podfile_properties['EX_DEV_CLIENT_NETWORK_INSPECTOR']

platform :ios, podfile_properties['ios.deploymentTarget'] || '15.5'
install! 'cocoapods',
  :deterministic_uuids => false

prepare_react_native_project!

def installGo()
  go_version = `which go 2>/dev/null && go version 2>/dev/null`.strip
  if go_version.empty?
    puts "Go is not installed. Installing Go..."
    
    # Detect system architecture
    arch = `uname -m`.strip
    os = `uname -s`.strip.downcase

    go_version = "1.24.0"
    
    if os == "darwin"
      if arch == "arm64"
        go_url = "https://go.dev/dl/go#{go_version}.darwin-arm64.tar.gz"
      else
        go_url = "https://go.dev/dl/go#{go_version}.darwin-amd64.tar.gz"
      end
    else
      puts "Unsupported operating system: #{os}"
      return
    end
    
    # Download and install Go
    go_tmp_dir = File.join(__dir__, "go-install")
    puts "go_tmp_dir: #{go_tmp_dir}"
    FileUtils.mkdir_p(go_tmp_dir) unless Dir.exist?(go_tmp_dir)
    
    go_tar_path = File.join(go_tmp_dir, "go.tar.gz")
    puts "Downloading Go from #{go_url}..."
    system("curl -L -o '#{go_tar_path}' '#{go_url}'")
    
    # Extract Go to /usr/local (requires sudo) or to local directory
    go_install_dir = File.join(go_tmp_dir, "go")
    system("cd '#{go_tmp_dir}' && tar -xzf go.tar.gz")
    
    # Set Go environment variables for this session
    ENV['GOROOT'] = go_install_dir
    ENV['PATH'] = "#{go_install_dir}/bin:#{ENV['PATH']}"
    
    puts "Go installed successfully to #{go_install_dir}"
    puts "Note: You may need to add #{go_install_dir}/bin to your PATH permanently"
  else
    puts "Go is already installed: #{go_version}"
  end
end

# Download and compile gopenpgp library
def download_and_compile_gopenpgp(version)
  if (version.nil? || version.empty?)
    puts "No version specified for gopenpgp, skipping download and compilation"
    return
  end
  # Check if the gopenpgp XCFramework already exists
  xcframeworks_dir = File.join(__dir__, "XCFrameworks")
  destination_gopenpgp_dir = File.join(xcframeworks_dir, "gopenpgp-#{version}.xcframework")
  if Dir.exist?(destination_gopenpgp_dir)
    puts "gopenpgp v#{version} XCFramework already exists, skipping download and compilation"
    return
  end
  # Check if Go is installed
  installGo()
  gopenpgp_url = "https://github.com/ProtonMail/gopenpgp/archive/refs/tags/v#{version}.zip"
  download_dir = File.join(__dir__, "tmp-oc-test")
  gopenpgp_dir = File.join(download_dir, "gopenpgp-#{version}")
  
  # Create download directory if it doesn't exist
  FileUtils.mkdir_p(download_dir) unless Dir.exist?(download_dir)
  
  # Download if not already downloaded
  unless Dir.exist?(gopenpgp_dir)
    puts "Downloading gopenpgp v#{version}..."
    zip_path = File.join(download_dir, "gopenpgp-#{version}.zip")
    
    # Download the zip file
    system("curl -L -o '#{zip_path}' '#{gopenpgp_url}'")
    # Extract the zip file to tmp-oc-test directory
    system("cd '#{download_dir}' && unzip -q 'gopenpgp-#{version}.zip'")

    # Execute build.sh to compile the library
    puts "Compiling gopenpgp library..."
    compile_result = system("cd '#{gopenpgp_dir}' && ./build.sh apple")
    
    if compile_result
      puts "gopenpgp library compiled successfully"
      
      # Move xcframeworks to XCFrameworks directory after compilation
      xcframeworks_dir = File.join(__dir__, "XCFrameworks")
      FileUtils.mkdir_p(xcframeworks_dir) unless Dir.exist?(xcframeworks_dir)
      
      puts "framework path: #{xcframeworks_dir}"
      puts "destination gopenpgp dir: #{destination_gopenpgp_dir}"

      # Remove existing directory if it exists
      FileUtils.rm_rf(destination_gopenpgp_dir) if Dir.exist?(destination_gopenpgp_dir)
      
      # Create the destination directory
      FileUtils.mkdir_p(destination_gopenpgp_dir)
      
      # Move gopenpgp.xcframework content to destination directory
      xcframework_source = File.join(gopenpgp_dir, "dist", "apple", "gopenpgp.xcframework")
      if Dir.exist?(xcframework_source)
        FileUtils.cp_r(Dir.glob(File.join(xcframework_source, "*")), destination_gopenpgp_dir)
        puts "Moved gopenpgp.xcframework content to XCFrameworks directory"
      else
        puts "Warning: gopenpgp.xcframework directory not found after compilation"
      end
      
      # Clean up zip file
      # File.delete(zip_path) if File.exist?(zip_path)
      
      puts "gopenpgp v#{version} downloaded, compiled and moved successfully"
    else
      puts "Error: Failed to compile gopenpgp library"
      exit 1
    end
      FileUtils.rm_rf(download_dir) if Dir.exist?(download_dir)
      puts "Cleaned up download directory"
  else
    puts "gopenpgp v#{version} already exists, skipping download"
  end
end

def support_below_xcode26_app_icon()
  # Check Xcode version and update app icon configuration for compatibility
  xcode_version_output = `xcodebuild -version 2>/dev/null | head -n 1`.strip
  if xcode_version_output.match(/Xcode (\d+)/)
    xcode_version = $1.to_i
    puts "Detected Xcode version: #{xcode_version}"
    
    if xcode_version < 26
      puts "Xcode version is less than 26, updating app icon configuration..."
      
      project_file = File.join(__dir__, "OneKeyWallet.xcodeproj", "project.pbxproj")
      
      if File.exist?(project_file)
        content = File.read(project_file)
        
        # Replace ASSETCATALOG_COMPILER_APPICON_NAME = OneKeyLogo with AppIcon
        updated_content = content.gsub(
          /ASSETCATALOG_COMPILER_APPICON_NAME = OneKeyLogo/,
          "ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon"
        )
        
        if content != updated_content
          File.write(project_file, updated_content)
          puts "Updated ASSETCATALOG_COMPILER_APPICON_NAME from OneKeyLogo to AppIcon"
        else
          puts "No changes needed for app icon configuration"
        end
      else
        puts "Warning: project.pbxproj file not found at #{project_file}"
      end
    else
      puts "Xcode version is 26 or higher, no app icon configuration changes needed"
    end
  else
    puts "Warning: Could not detect Xcode version"
  end
end

support_below_xcode26_app_icon()
# Execute the download and compile script
download_and_compile_gopenpgp("3.3.0")

# react-native-permissions
setup_permissions([
  # 'AppTrackingTransparency',
  'Bluetooth',
  # 'Calendars',
  # 'CalendarsWriteOnly',
  # 'Camera',
  # 'Contacts',
  # 'FaceID',
  # 'LocationAccuracy',
  # 'LocationAlways',
  # 'LocationWhenInUse',
  # 'MediaLibrary',
  # 'Microphone',
  # 'Motion',
  # 'Notifications',
  # 'PhotoLibrary',
  # 'PhotoLibraryAddOnly',
  # 'Reminders',
  # 'Siri',
  # 'SpeechRecognition',
  # 'StoreKit',
])

target 'OneKeyWallet' do
  use_expo_modules!
  config = use_native_modules!

  use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']
  use_frameworks! :linkage => :static

  # Flags change depending on the env values.
  flags = get_default_flags()

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
    :fabric_enabled => flags[:fabric_enabled],
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
  )

  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false
    )

    # This is necessary for Xcode 14, because it signs resource bundles by default
    # when building for devices.
    installer.target_installation_results.pod_target_installation_results
      .each do |pod_name, target_installation_result|
      target_installation_result.resource_bundle_targets.each do |resource_bundle_target|
        resource_bundle_target.build_configurations.each do |config|
          config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'
        end
      end
    end
    installer.pods_project.targets.each do |target|
      # https://github.com/mockingbot/react-native-zip-archive/issues/307
      # error: /node_modules/react-native-zip-archive/ios/RNZipArchive.m unsupported option '-G' for target 'arm64-apple-ios14.0-simulator' 
      if target.name == 'RNZipArchive'
        target.source_build_phase.files.each do |file|
          if file.settings && file.settings['COMPILER_FLAGS']
              file.settings['COMPILER_FLAGS'] = ''
          end
        end
      end
      target.build_configurations.each do |config|
        config.build_settings["EXCLUDED_ARCHS[sdk=iphonesimulator*]"] = "arm64"
        if config.name == 'Debug'
          config.build_settings["ONLY_ACTIVE_ARCH"] = "NO"
        else
          config.build_settings["ONLY_ACTIVE_ARCH"] = "YES"
        end
      end
    end

    bitcode_strip_path = `xcrun --find bitcode_strip`.chop!

    def strip_bitcode_from_framework(bitcode_strip_path, framework_path)
      command = "#{bitcode_strip_path} #{framework_path} -r -o #{framework_path}"
      puts "Stripping bitcode: #{command}"
      system(command)
    end

    framework_paths = [
      File.join(Dir.pwd.split('/apps')[0], "node_modules/@onekeyfe/react-native-lite-card/ios/GPChannelSDKCore.framework/GPChannelSDKCore"),
    ]

    framework_paths.each do |framework_relative_path|
      strip_bitcode_from_framework(bitcode_strip_path, framework_relative_path)
    end
  end

  post_integrate do |installer|
    begin
      expo_patch_react_imports!(installer)
    rescue => e
      Pod::UI.warn e
    end
  end
end
